name: Update README with Blueprints

on:
  push:
    branches:
      - main
    paths:
      - '**/**.yaml'
      - '!.github/**'

jobs:
  update-readme:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Setup yq
        uses: mikefarah/yq-action@master # This action installs yq

      - name: Generate blueprint table
        id: generate
        run: |
          echo "Scanning for blueprints..."

          # Start building the table
          TABLE="| Blueprint | Description | Import |
          |-----------|-------------|--------|"

          # Find all blueprint yaml files (excluding .github and .worktrees top level)
          # Use find command to get relative paths for yq and URL encoding
          find . -maxdepth 3 -name "*.yaml" -type f ! -path "./.github/*" ! -path "./.worktrees/*/.auto-claude/*" -print0 | while IFS= read -r yaml_file; do
            # Ensure we only process yaml files directly or within a blueprint folder
            if [[ "$yaml_file" == *"/.worktrees/"* ]] && [[ "$(basename $(dirname "$yaml_file"))" == "specs" ]]; then
                continue # Skip files inside .auto-claude/specs within worktrees
            fi
            if [[ "$yaml_file" == *"/.github/"* ]]; then
                continue # Skip files inside .github
            fi

            # Get directory name and blueprint name (from file system or inside YAML)
            dir_name=$(dirname "$yaml_file")
            dir_name_basename=$(basename "$dir_name")
            blueprint_file_basename=$(basename "$yaml_file")

            # Skip hidden directories and non-blueprint folders
            [[ "$dir_name_basename" == .* ]] && continue

            # Extract the path segment for the repo URL.
            # This needs to correctly handle blueprints at the root vs inside worktrees.
            repo_path_for_url=${yaml_file#./} # Remove leading './'

            # Use yq to extract name and description
            # Use --prettyPrint false to get raw output
            # Use .blueprint.name and .blueprint.description as common paths, fallback to directory name if needed
            blueprint_name_raw=$(yq -r '.blueprint.name' "$yaml_file" 2>/dev/null)
            blueprint_desc_raw=$(yq -r '.blueprint.description' "$yaml_file" 2>/dev/null)

            # Fallback for name if not found or contains unicode escapes
            if [[ -z "$blueprint_name_raw" ]] || [[ "$blueprint_name_raw" == *"\\U"* ]]; then
              # Try to get a human-readable name from the directory name
              display_name=$(echo "$dir_name_basename" | sed 's/_/ /g' | sed 's/\b\(.\)/\u\1/g')
              emoji="ðŸ " # Default emoji
            else
              display_name="$blueprint_name_raw"
              # Extract emoji from name or assign based on directory
              case "$dir_name_basename" in
                ai_parking*) emoji="ðŸš—" ;; 
                ai_weather*) emoji="ðŸŒ¤ï¸" ;; 
                doorbell*) emoji="ðŸ””" ;; 
                presence_lights*) emoji="ðŸ’¡" ;; # Added specific worktree case
                volumecontrol*) emoji="ðŸ”ˆ" ;; # Added specific worktree case
                *) emoji="ðŸ " ;; # Default emoji
              esac
            fi
            
            # Process description
            version="v?"
            short_desc=""

            if [[ -n "$blueprint_desc_raw" ]]; then
              # Try to parse version (vX.Y.Z or vX.Y) and description
              if [[ "$blueprint_desc_raw" =~ ^v([0-9]+\.[0-9]+(\.[0-9]+)?)\s*-\s*(.*)$ ]]; then
                version="v${BASH_REMATCH[1]}"
                short_desc="${BASH_REMATCH[3]}"
              elif [[ "$blueprint_desc_raw" =~ ^v([0-9]+\.[0-9]+(\.[0-9]+)?)$ ]]; then
                version="v${BASH_REMATCH[1]}"
                short_desc="No specific description provided."
              else
                # No version found, use the whole string as description if it's not too long
                short_desc="$blueprint_desc_raw"
              fi
            else
              short_desc="No description found."
            fi

            # Clean up short description (remove leading/trailing spaces, hyphens, and Features:...)
            short_desc=$(echo "$short_desc" | sed 's/^ *- *//' | sed 's/ *$//' | sed 's/Features:.*//' | sed 's/^ *//')

            # Truncate short description if it's too long (aiming for ~80 total chars with version)
            max_total_len=80 # Target total length for "vX.Y.Z - Description"
            current_version_len=${#version}
            
            # Calculate remaining length for description, considering formatting like " - "
            # Minimum space needed is "vX - ", which is 5 chars if version is short.
            # If version is "v?", length is 2. If "v1.2.3", length is 7.
            # We need at least 3 chars for " - " plus the version length.
            # Let's ensure remaining_len is at least 5 to avoid issues.
            remaining_len=$((max_total_len - current_version_len - 3)) 
            if [[ $remaining_len -lt 5 ]]; then # Ensure there's enough space for minimum desc part
                remaining_len=5
            fi

            if [[ "$short_desc" != "No description found." && "$short_desc" != "No specific description provided." ]]; then
              if [[ ${#short_desc} -gt $remaining_len ]]; then
                short_desc="${short_desc:0:$((remaining_len-3))}..."
              fi
            else
              # Ensure placeholder descriptions are also within limits if they are too long
              if [[ ${#short_desc} -gt $remaining_len ]]; then
                short_desc="${short_desc:0:$((remaining_len-3))}..."
              fi
            fi

            # Final formatted description for README
            formatted_description="$version - $short_desc"

            # Add row to table
            TABLE="$TABLE
        | $emoji **[$display_name](${repo_path_for_url}) | $formatted_description | [![Import](https://my.home-assistant.io/badges/blueprint_import.svg)]($import_url) |"
          done

          # Save table to file
          echo "$TABLE" > /tmp/blueprint_table.md
          cat /tmp/blueprint_table.md

      - name: Update README
        run: |
          # Read the current README
          readme_content=$(cat README.md)

          # Read the generated table
          new_table=$(cat /tmp/blueprint_table.md)

          # Create new README with updated table
          # Find the section between "## âœ¨ Available Blueprints" and the next "##"
          # Using awk to replace the section. The 'skip' variable controls when to print.
          awk -v table="$new_table" '
            /^## âœ¨ Available Blueprints/ {
              print
              print ""
              print "Currently, this repository offers the following blueprints:"
              print ""
              print table
              print ""
              skip=1 # Start skipping lines after the new table is inserted
              next
            }
            /^## / && skip { # If we encounter another section header and are skipping
              skip=0 # Stop skipping
            }
            !skip { # If not skipping, print the line
              print
            }
          ' README.md > README.md.new

          # Check if the replacement actually happened, if not, append the table.
          # This is a fallback in case the "## âœ¨ Available Blueprints" header wasn't found.
          if ! grep -q "Currently, this repository offers the following blueprints:" README.md.new; then
            echo "Warning: Could not find the section '## âœ¨ Available Blueprints' in README.md. Appending table instead."
            echo -e "\n## âœ¨ Available Blueprints\n" >> README.md.new
            echo "Currently, this repository offers the following blueprints:" >> README.md.new
            echo "" >> README.md.new
            cat /tmp/blueprint_table.md >> README.md.new
            echo "" >> README.md.new
          fi

          mv README.md.new README.md

          echo "Updated README.md:"
          cat README.md

      - name: Check for changes
        id: check
        run: |
          # Check if README.md has been modified
          if git diff --quiet README.md; then
            echo "changed=false" >> $GITHUB_OUTPUT
          else
            echo "changed=true" >> $GITHUB_OUTPUT
          fi

      - name: Commit and push
        # Only run if changes were detected by the previous step
        if: steps.check.outputs.changed == 'true'
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git add README.md
          # Commit message should be in English and prefixed with an emoji
          COMMIT_MESSAGE="ðŸ¤– Auto-update README with blueprint list and versioned descriptions"
          git commit -m "$COMMIT_MESSAGE"
          echo "Pushing changes..."
          git push